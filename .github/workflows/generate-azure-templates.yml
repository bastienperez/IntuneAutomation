name: Generate Azure Deployment Templates

on:
  push:
    branches: [main]
    paths:
      - "scripts/**/*.ps1"
  pull_request:
    branches: [main]
    paths:
      - "scripts/**/*.ps1"
  workflow_dispatch:

permissions:
  contents: write

jobs:
  generate-templates:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate Azure ARM Templates
        shell: pwsh
        run: |
          # Load required assemblies
          Add-Type -AssemblyName System.Web

          # Create output directory
          $outputDir = "azure-templates"
          if (Test-Path $outputDir) {
              Remove-Item $outputDir -Recurse -Force
          }
          New-Item -ItemType Directory -Path $outputDir -Force | Out-Null

          # Initialize the templates registry
          $templatesRegistry = @{
              generated = (Get-Date -Format "yyyy-MM-ddTHH:mm:ssZ")
              templates = @{}
          }

          # Function to parse PowerShell script metadata
          function Get-ScriptMetadata {
              param([string]$FilePath)
              
              $content = Get-Content $FilePath -Raw
              $metadata = @{}
              
              # Extract metadata from comment block
              if ($content -match '(?s)<#(.*?)#>') {
                  $commentBlock = $Matches[1]
                  
                  # Parse each metadata field
                  $fields = @('TITLE', 'SYNOPSIS', 'DESCRIPTION', 'TAGS', 'PERMISSIONS', 'AUTHOR', 'VERSION', 'MINROLE')
                  foreach ($field in $fields) {
                      if ($commentBlock -match "(?m)^\s*\.$field\s*\r?\n\s*(.+?)(?=\r?\n\s*\.|$)") {
                          $metadata[$field] = $Matches[1].Trim()
                      }
                  }
              }
              
              return $metadata
          }

          # Function to generate Azure Automation compatible script
          function ConvertTo-AzureAutomationScript {
              param([string]$OriginalScript, [hashtable]$Metadata)
              
              # Create the dual-environment authentication section
              $authLines = @(
                  '# ============================================================================',
                  '# AUTHENTICATION - DUAL ENVIRONMENT SUPPORT',
                  '# ============================================================================',
                  '',
                  '# Detect execution environment',
                  'if ($PSPrivateMetadata.JobId.Guid) {',
                  '    Write-Output "Running inside Azure Automation Runbook"',
                  '    $IsRunbook = $true',
                  '} else {',
                  '    Write-Output "Running locally in IDE or terminal"',
                  '    $IsRunbook = $false',
                  '}',
                  '',
                  '# Authentication logic based on environment',
                  'if ($IsRunbook) {',
                  '    # Azure Automation Runbook - Use Managed Identity',
                  '    try {',
                  '        Write-Output "Connecting to Microsoft Graph using Managed Identity..."',
                  '        Connect-MgGraph -Identity -NoWelcome',
                  '        Write-Output "✓ Successfully connected to Microsoft Graph using Managed Identity"',
                  '    }',
                  '    catch {',
                  '        Write-Error "Failed to connect to Microsoft Graph using Managed Identity: $($_.Exception.Message)"',
                  '        throw',
                  '    }',
                  '} else {',
                  '    # Local execution - Use interactive authentication',
                  '    # Check if required modules are installed',
                  '    $RequiredModules = @(',
                  '        "Microsoft.Graph.Authentication"',
                  '    )',
                  '',
                  '    foreach ($Module in $RequiredModules) {',
                  '        if (-not (Get-Module -ListAvailable -Name $Module)) {',
                  '            Write-Error "$Module module is required. Install it using: Install-Module $Module -Scope CurrentUser"',
                  '            exit 1',
                  '        }',
                  '    }',
                  '',
                  '    # Import required modules',
                  '    foreach ($Module in $RequiredModules) {',
                  '        Import-Module $Module',
                  '    }',
                  '',
                  '    # Connect to Microsoft Graph with required scopes',
                  '    try {',
                  '        Write-Information "Connecting to Microsoft Graph..." -InformationAction Continue',
                  '        $Scopes = @(',
                  "            `"$($Metadata.PERMISSIONS)`"",
                  '        )',
                  '        Connect-MgGraph -Scopes $Scopes -NoWelcome',
                  '        Write-Information "✓ Successfully connected to Microsoft Graph" -InformationAction Continue',
                  '    }',
                  '    catch {',
                  '        Write-Error "Failed to connect to Microsoft Graph: $($_.Exception.Message)"',
                  '        exit 1',
                  '    }',
                  '}'
              )
              
              $authSection = $authLines -join "`n"
              
              # Replace existing authentication section or insert after modules section
              $authSectionRegex = '(?s)# ============================================================================\s*\r?\n\s*# (?:MODULES AND )?AUTHENTICATION.*?(?=# ============================================================================\s*\r?\n\s*# HELPER FUNCTIONS|# ============================================================================\s*\r?\n\s*# MAIN SCRIPT LOGIC|$)'
              
              if ($OriginalScript -match $authSectionRegex) {
                  $modifiedScript = $OriginalScript -replace $authSectionRegex, $authSection
              } else {
                  # If no authentication section found, insert after parameters
                  $paramEndRegex = '(?s)(\[CmdletBinding\(\)\]\s*param\s*\([^}]*\}\s*)?'
                  if ($OriginalScript -match $paramEndRegex) {
                      $insertPoint = $Matches[0].Length
                      $modifiedScript = $OriginalScript.Substring(0, $insertPoint) + "`n`n" + $authSection + "`n`n" + $OriginalScript.Substring($insertPoint)
                  } else {
                      $modifiedScript = $OriginalScript + "`n`n" + $authSection
                  }
              }
              
              return $modifiedScript
          }

          # Function to generate ARM template
          function New-AzureARMTemplate {
              param(
                  [string]$ScriptId,
                  [string]$ScriptContent,
                  [hashtable]$Metadata
              )
              
              # Save the Azure Automation compatible script to a separate file
              $azureScriptPath = "azure-scripts/$ScriptId.ps1"
              $azureScriptDir = Split-Path $azureScriptPath -Parent
              if (-not (Test-Path $azureScriptDir)) {
                  New-Item -ItemType Directory -Path $azureScriptDir -Force | Out-Null
              }
              Set-Content -Path $azureScriptPath -Value $ScriptContent -Encoding UTF8
              
              $template = @{
                  '$schema' = "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#"
                  contentVersion = "1.0.0.0"
                  parameters = @{
                      automationAccountName = @{
                          type = "string"
                          metadata = @{
                              description = "Name of your existing Azure Automation Account (must exist in the selected resource group)"
                          }
                      }
                      runbookName = @{
                          type = "string"
                          defaultValue = $ScriptId
                          metadata = @{
                              description = "Name for the new runbook (will be created in the Automation Account)"
                          }
                      }
                      runbookDescription = @{
                          type = "string"
                          defaultValue = ($Metadata.DESCRIPTION -replace '"', '\"')
                          metadata = @{
                              description = "Description of the runbook"
                          }
                      }
                      location = @{
                          type = "string"
                          defaultValue = "[resourceGroup().location]"
                          metadata = @{
                              description = "Location for the runbook deployment"
                          }
                      }
                  }
                  variables = @{
                      runbookType = "PowerShell"
                      logProgress = $false
                      logVerbose = $false
                      scriptUrl = "https://raw.githubusercontent.com/ugurkocde/IntuneAutomation/main/azure-scripts/$($ScriptId).ps1"
                  }
                  resources = @(
                      @{
                          type = "Microsoft.Automation/automationAccounts/runbooks"
                          apiVersion = "2020-01-13-preview"
                          name = "[concat(parameters('automationAccountName'), '/', parameters('runbookName'))]"
                          location = "[parameters('location')]"
                          properties = @{
                              runbookType = "[variables('runbookType')]"
                              logProgress = "[variables('logProgress')]"
                              logVerbose = "[variables('logVerbose')]"
                              description = "[parameters('runbookDescription')]"
                              publishContentLinkUri = "[variables('scriptUrl')]"
                          }
                      }
                  )
                  outputs = @{
                      runbookName = @{
                          type = "string"
                          value = "[parameters('runbookName')]"
                      }
                      automationAccountName = @{
                          type = "string"
                          value = "[parameters('automationAccountName')]"
                      }
                      runbookUrl = @{
                          type = "string"
                          value = "[concat('https://portal.azure.com/#@', subscription().tenantId, '/resource/subscriptions/', subscription().subscriptionId, '/resourceGroups/', resourceGroup().name, '/providers/Microsoft.Automation/automationAccounts/', parameters('automationAccountName'), '/runbooks/', parameters('runbookName'))]"
                      }
                      deploymentInstructions = @{
                          type = "string"
                          value = "Runbook created and published successfully! Next steps: 1) Ensure your Automation Account has Managed Identity enabled, 2) Assign required Microsoft Graph permissions to the Managed Identity, 3) Test the runbook."
                      }
                  }
              }
              
              return $template
          }

          # Process all PowerShell scripts
          $scriptFiles = Get-ChildItem -Path "scripts" -Recurse -Filter "*.ps1"

          foreach ($scriptFile in $scriptFiles) {
              Write-Host "Processing: $($scriptFile.FullName)"
              
              # Get script metadata
              $metadata = Get-ScriptMetadata -FilePath $scriptFile.FullName
              $scriptId = [System.IO.Path]::GetFileNameWithoutExtension($scriptFile.Name)
              
              # Read original script content
              $originalScript = Get-Content $scriptFile.FullName -Raw
              
              # Convert to Azure Automation compatible script
              $azureScript = ConvertTo-AzureAutomationScript -OriginalScript $originalScript -Metadata $metadata
              
              # Generate ARM template
              $armTemplate = New-AzureARMTemplate -ScriptId $scriptId -ScriptContent $azureScript -Metadata $metadata
              
              # Save ARM template to file
              $templateFileName = "$scriptId-azure-deployment.json"
              $templatePath = Join-Path $outputDir $templateFileName
              $armTemplate | ConvertTo-Json -Depth 10 | Set-Content $templatePath -Encoding UTF8
              
              # Generate GitHub raw URL for the template
              $templateUrl = "https://raw.githubusercontent.com/$env:GITHUB_REPOSITORY/main/$outputDir/$templateFileName"
              
              # Add to registry
              $templatesRegistry.templates[$scriptId] = @{
                  title = $metadata.TITLE
                  description = $metadata.DESCRIPTION
                  tags = $metadata.TAGS -split ','
                  permissions = $metadata.PERMISSIONS -split ','
                  author = $metadata.AUTHOR
                  version = $metadata.VERSION
                  templateUrl = $templateUrl
                  deployUrl = "https://portal.azure.com/#create/Microsoft.Template/uri/$([System.Web.HttpUtility]::UrlEncode($templateUrl))"
                  scriptPath = $scriptFile.FullName.Replace((Get-Location).Path + [System.IO.Path]::DirectorySeparatorChar, "").Replace('\', '/')
              }
              
              Write-Host "✓ Generated template for $scriptId"
          }

          # Save the templates registry
          $templatesRegistry | ConvertTo-Json -Depth 10 | Set-Content "azure-deployment-templates.json" -Encoding UTF8

          Write-Host "✓ Generated $($scriptFiles.Count) Azure deployment templates"
          Write-Host "✓ Created azure-deployment-templates.json registry"

      - name: Commit generated templates
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add azure-templates/ azure-scripts/ azure-deployment-templates.json
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "Auto-generate Azure deployment templates and scripts [skip ci]"
            git push
          fi
