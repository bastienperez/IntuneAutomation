{
  "parameters": {
    "runbookName": {
      "type": "string",
      "metadata": {
        "description": "Name of the runbook to create"
      },
      "defaultValue": "get-unassigned-policies"
    },
    "automationAccountName": {
      "type": "string",
      "metadata": {
        "description": "Name of the Azure Automation Account where the runbook will be created"
      }
    },
    "runbookDescription": {
      "type": "string",
      "metadata": {
        "description": "Description of the runbook"
      },
      "defaultValue": "This script connects to Microsoft Graph and analyzes all Intune policies to identify"
    }
  },
  "variables": {
    "runbookType": "PowerShell",
    "logProgress": false,
    "scriptContent": "<#\n.TITLE\n    Unassigned Policies Report\n\n.SYNOPSIS\n    Identifies all Intune policies that have no group or user assignments\n\n.DESCRIPTION\n    This script connects to Microsoft Graph and analyzes all Intune policies to identify\n    which ones have no assignments. It checks device configuration policies, device compliance\n    policies, app protection policies, and Settings Catalog policies. The script provides a \n    comprehensive report showing policies that may be obsolete or forgotten, helping \n    administrators maintain a clean policy environment.\n\n.TAGS\n    Operational,Reporting\n\n.MINROLE\n    Intune Administrator\n\n.PERMISSIONS\n    DeviceManagementConfiguration.Read.All,DeviceManagementApps.Read.All,DeviceManagementManagedDevices.Read.All\n\n.AUTHOR\n    Ugur Koc\n\n.VERSION\n    1.0\n\n.CHANGELOG\n    1.0 - Initial release\n\n.EXAMPLE\n    .\\get-unassigned-policies.ps1\n    Displays all unassigned policies in the console\n\n.EXAMPLE\n    .\\get-unassigned-policies.ps1 -ExportPath \"C:\\Reports\\UnassignedPolicies.csv\"\n    Exports unassigned policies to a CSV file\n\n.NOTES\n    - Requires only Microsoft.Graph.Authentication module\n    - Uses Connect-MgGraph and Invoke-MgGraphRequest for all Graph operations\n    - Checks policy types: Device Configuration, Device Compliance, App Protection, Settings Catalog\n    - Settings Catalog policies require beta Graph endpoint access\n    - App Protection policies are considered assigned if they exist (different targeting model)\n    - Policies with no assignments may indicate unused or forgotten configurations\n    - Consider reviewing these policies for potential cleanup or assignment\n#>\n\n[CmdletBinding()]\nparam(\n    [Parameter(Mandatory = $false, HelpMessage = \"Path to export the results to CSV file\")]\n    [string]$ExportPath,\n    \n    [Parameter(Mandatory = $false, HelpMessage = \"Include detailed assignment information in output\")]\n    [switch]$IncludeDetails\n)\n\n# ============================================================================\n# AUTHENTICATION - DUAL ENVIRONMENT SUPPORT\n# ============================================================================\n\n# Detect execution environment\nif ($PSPrivateMetadata.JobId.Guid) {\n    Write-Output \"Running inside Azure Automation Runbook\"\n    $IsRunbook = $true\n} else {\n    Write-Output \"Running locally in IDE or terminal\"\n    $IsRunbook = $false\n}\n\n# Authentication logic based on environment\nif ($IsRunbook) {\n    # Azure Automation Runbook - Use Managed Identity\n    try {\n        Write-Output \"Connecting to Microsoft Graph using Managed Identity...\"\n        Connect-MgGraph -Identity -NoWelcome\n        Write-Output \"✓ Successfully connected to Microsoft Graph using Managed Identity\"\n    }\n    catch {\n        Write-Error \"Failed to connect to Microsoft Graph using Managed Identity: $(<#\n.TITLE\n    Unassigned Policies Report\n\n.SYNOPSIS\n    Identifies all Intune policies that have no group or user assignments\n\n.DESCRIPTION\n    This script connects to Microsoft Graph and analyzes all Intune policies to identify\n    which ones have no assignments. It checks device configuration policies, device compliance\n    policies, app protection policies, and Settings Catalog policies. The script provides a \n    comprehensive report showing policies that may be obsolete or forgotten, helping \n    administrators maintain a clean policy environment.\n\n.TAGS\n    Operational,Reporting\n\n.MINROLE\n    Intune Administrator\n\n.PERMISSIONS\n    DeviceManagementConfiguration.Read.All,DeviceManagementApps.Read.All,DeviceManagementManagedDevices.Read.All\n\n.AUTHOR\n    Ugur Koc\n\n.VERSION\n    1.0\n\n.CHANGELOG\n    1.0 - Initial release\n\n.EXAMPLE\n    .\\get-unassigned-policies.ps1\n    Displays all unassigned policies in the console\n\n.EXAMPLE\n    .\\get-unassigned-policies.ps1 -ExportPath \"C:\\Reports\\UnassignedPolicies.csv\"\n    Exports unassigned policies to a CSV file\n\n.NOTES\n    - Requires only Microsoft.Graph.Authentication module\n    - Uses Connect-MgGraph and Invoke-MgGraphRequest for all Graph operations\n    - Checks policy types: Device Configuration, Device Compliance, App Protection, Settings Catalog\n    - Settings Catalog policies require beta Graph endpoint access\n    - App Protection policies are considered assigned if they exist (different targeting model)\n    - Policies with no assignments may indicate unused or forgotten configurations\n    - Consider reviewing these policies for potential cleanup or assignment\n#>\n\n[CmdletBinding()]\nparam(\n    [Parameter(Mandatory = $false, HelpMessage = \"Path to export the results to CSV file\")]\n    [string]$ExportPath,\n    \n    [Parameter(Mandatory = $false, HelpMessage = \"Include detailed assignment information in output\")]\n    [switch]$IncludeDetails\n)\n\n# ============================================================================\n# MODULES AND AUTHENTICATION\n# ============================================================================\n\n# Check if required modules are installed\n$RequiredModules = @(\n    \"Microsoft.Graph.Authentication\"\n)\n\nforeach ($Module in $RequiredModules) {\n    if (-not (Get-Module -ListAvailable -Name $Module)) {\n        Write-Error \"$Module module is required. Install it using: Install-Module $Module -Scope CurrentUser\"\n        exit 1\n    }\n}\n\n# Import required modules\nforeach ($Module in $RequiredModules) {\n    Import-Module $Module\n}\n\n# Connect to Microsoft Graph\ntry {\n    Write-Information \"Connecting to Microsoft Graph...\" -InformationAction Continue\n    $Scopes = @(\n        \"DeviceManagementConfiguration.Read.All\",\n        \"DeviceManagementApps.Read.All\",\n        \"DeviceManagementManagedDevices.Read.All\"\n    )\n    Connect-MgGraph -Scopes $Scopes -NoWelcome\n    Write-Information \"✓ Successfully connected to Microsoft Graph\" -InformationAction Continue\n}\ncatch {\n    Write-Error \"Failed to connect to Microsoft Graph: $($_.Exception.Message)\"\n    exit 1\n}\n\n# ============================================================================\n# HELPER FUNCTIONS\n# ============================================================================\n\n# Function to get all pages of results from Graph API\nfunction Get-MgGraphAllPage {\n    param(\n        [Parameter(Mandatory = $true)]\n        [string]$Uri,\n        [int]$DelayMs = 100\n    )\n    \n    $AllResults = @()\n    $NextLink = $Uri\n    $RequestCount = 0\n    \n    do {\n        try {\n            # Add delay to respect rate limits\n            if ($RequestCount -gt 0) {\n                Start-Sleep -Milliseconds $DelayMs\n            }\n            \n            $Response = Invoke-MgGraphRequest -Uri $NextLink -Method GET\n            $RequestCount++\n            \n            if ($Response.value) {\n                $AllResults += $Response.value\n            }\n            else {\n                $AllResults += $Response\n            }\n            \n            $NextLink = $Response.'@odata.nextLink'\n        }\n        catch {\n            if ($_.Exception.Message -like \"*429*\" -or $_.Exception.Message -like \"*throttled*\") {\n                Write-Information \"`nRate limit hit, waiting 60 seconds...\" -InformationAction Continue\n                Start-Sleep -Seconds 60\n                continue\n            }\n            Write-Warning \"Error fetching data from $NextLink : $($_.Exception.Message)\"\n            break\n        }\n    } while ($NextLink)\n    \n    return $AllResults\n}\n\n# Function to check if a policy has assignments\nfunction Test-PolicyAssignment {\n    param(\n        [Parameter(Mandatory = $true)]\n        [string]$PolicyId,\n        [Parameter(Mandatory = $true)]\n        [string]$PolicyType\n    )\n    \n    # Check if PolicyId is valid\n    if ([string]::IsNullOrWhiteSpace($PolicyId)) {\n        Write-Warning \"PolicyId is empty or null for $PolicyType policy\"\n        return $false\n    }\n    \n    try {\n        # App Protection policies use a different targeting mechanism\n        if ($PolicyType -eq \"AppProtection\") {\n            # App Protection policies don't use traditional assignments\n            # They are applied to applications and considered active if they exist\n            try {\n                # Verify the policy exists and is accessible\n                $PolicyUri = \"https://graph.microsoft.com/v1.0/deviceAppManagement/managedAppPolicies/$PolicyId\"\n                $null = Invoke-MgGraphRequest -Uri $PolicyUri -Method GET\n                \n                # App Protection policies are considered \"assigned\" if they exist and are published\n                # Most App Protection policies that exist are active/assigned to applications\n                return $true\n            }\n            catch {\n                # If we can't access the policy, it might not be properly configured\n                return $false\n            }\n        }\n        else {\n            $AssignmentUri = switch ($PolicyType) {\n                \"DeviceConfiguration\" { \"https://graph.microsoft.com/v1.0/deviceManagement/deviceConfigurations/$PolicyId/assignments\" }\n                \"DeviceCompliance\" { \"https://graph.microsoft.com/v1.0/deviceManagement/deviceCompliancePolicies/$PolicyId/assignments\" }\n                \"SettingsCatalog\" { \"https://graph.microsoft.com/beta/deviceManagement/configurationPolicies/$PolicyId/assignments\" }\n                default { return $false }\n            }\n            \n            $Assignments = Get-MgGraphAllPage -Uri $AssignmentUri\n            return $Assignments.Count -gt 0\n        }\n    }\n    catch {\n        Write-Warning \"Could not check assignments for policy $PolicyId : $($_.Exception.Message)\"\n        return $false\n    }\n}\n\n# Function to get policy details\nfunction Get-PolicyDetail {\n    param(\n        [Parameter(Mandatory = $true)]\n        [object]$Policy,\n        [Parameter(Mandatory = $true)]\n        [string]$PolicyType\n    )\n    \n    # Settings Catalog policies use 'name' instead of 'displayName'\n    $PolicyDisplayName = if ($PolicyType -eq \"SettingsCatalog\") {\n        $Policy.name\n    }\n    else {\n        $Policy.displayName\n    }\n    \n    $Details = [PSCustomObject]@{\n        PolicyType           = $PolicyType\n        PolicyId             = $Policy.id\n        DisplayName          = $PolicyDisplayName\n        Description          = $Policy.description\n        CreatedDateTime      = $Policy.createdDateTime\n        LastModifiedDateTime = $Policy.lastModifiedDateTime\n        Version              = $Policy.version\n        HasAssignments       = $false\n    }\n    \n    # Check for assignments\n    $Details.HasAssignments = Test-PolicyAssignment -PolicyId $Policy.id -PolicyType $PolicyType\n    \n    return $Details\n}\n\n# ============================================================================\n# MAIN SCRIPT LOGIC\n# ============================================================================\n\ntry {\n    Write-Information \"Starting unassigned policies analysis...\" -InformationAction Continue\n    \n    $UnassignedPolicies = @()\n    $PolicyTypes = @(\n        @{ Name = \"DeviceConfiguration\"; Uri = \"https://graph.microsoft.com/v1.0/deviceManagement/deviceConfigurations\" },\n        @{ Name = \"DeviceCompliance\"; Uri = \"https://graph.microsoft.com/v1.0/deviceManagement/deviceCompliancePolicies\" },\n        @{ Name = \"AppProtection\"; Uri = \"https://graph.microsoft.com/v1.0/deviceAppManagement/managedAppPolicies\" },\n        @{ Name = \"SettingsCatalog\"; Uri = \"https://graph.microsoft.com/beta/deviceManagement/configurationPolicies\" }\n    )\n    \n    foreach ($PolicyType in $PolicyTypes) {\n        Write-Information \"Analyzing $($PolicyType.Name) policies...\" -InformationAction Continue\n        \n        try {\n            $Policies = Get-MgGraphAllPage -Uri $PolicyType.Uri\n            # Handle null or empty results\n            if (-not $Policies) {\n                $Policies = @()\n            }\n            Write-Information \"Found $($Policies.Count) $($PolicyType.Name) policies\" -InformationAction Continue\n            \n            foreach ($Policy in $Policies) {\n                # Skip policies with empty or null IDs\n                if ([string]::IsNullOrWhiteSpace($Policy.id)) {\n                    $PolicyName = if ($PolicyType.Name -eq \"SettingsCatalog\") { $Policy.name } else { $Policy.displayName }\n                    Write-Warning \"Skipping policy with empty ID: $($PolicyName ?? 'Unknown')\"\n                    continue\n                }\n                \n                $PolicyDetails = Get-PolicyDetail -Policy $Policy -PolicyType $PolicyType.Name\n                \n                # Get the correct display name for Settings Catalog vs other policies\n                $DisplayName = if ($PolicyType.Name -eq \"SettingsCatalog\") {\n                    $Policy.name\n                }\n                else {\n                    $Policy.displayName\n                }\n                \n                if (-not $PolicyDetails.HasAssignments) {\n                    $UnassignedPolicies += $PolicyDetails\n                    Write-Information \"✗ Unassigned: $DisplayName ($($PolicyType.Name))\" -InformationAction Continue\n                }\n                else {\n                    Write-Information \"✓ Assigned: $DisplayName ($($PolicyType.Name))\" -InformationAction Continue\n                }\n            }\n        }\n        catch {\n            Write-Warning \"Error analyzing $($PolicyType.Name) policies: $($_.Exception.Message)\"\n        }\n    }\n    \n    # Display results\n    Write-Information \"`n========================================\" -InformationAction Continue\n    Write-Information \"UNASSIGNED POLICIES SUMMARY\" -InformationAction Continue\n    Write-Information \"========================================\" -InformationAction Continue\n    \n    if ($UnassignedPolicies.Count -eq 0) {\n        Write-Information \"✓ No unassigned policies found - all policies have assignments!\" -InformationAction Continue\n    }\n    else {\n        Write-Information \"Found $($UnassignedPolicies.Count) policies without assignments:\" -InformationAction Continue\n        \n        $GroupedPolicies = $UnassignedPolicies | Group-Object PolicyType\n        foreach ($Group in $GroupedPolicies) {\n            Write-Information \"`n$($Group.Name) Policies ($($Group.Count)):\" -InformationAction Continue\n            foreach ($Policy in $Group.Group) {\n                Write-Information \"  - $($Policy.DisplayName)\" -InformationAction Continue\n                if ($IncludeDetails) {\n                    Write-Information \"    ID: $($Policy.PolicyId)\" -InformationAction Continue\n                    Write-Information \"    Created: $($Policy.CreatedDateTime)\" -InformationAction Continue\n                    Write-Information \"    Modified: $($Policy.LastModifiedDateTime)\" -InformationAction Continue\n                }\n            }\n        }\n        \n        # Export to CSV if path provided\n        if ($ExportPath) {\n            try {\n                $UnassignedPolicies | Export-Csv -Path $ExportPath -NoTypeInformation\n                Write-Information \"`n✓ Results exported to: $ExportPath\" -InformationAction Continue\n            }\n            catch {\n                Write-Error \"Failed to export results: $($_.Exception.Message)\"\n            }\n        }\n    }\n    \n    Write-Information \"`n✓ Analysis completed successfully\" -InformationAction Continue\n}\ncatch {\n    Write-Error \"Script failed: $($_.Exception.Message)\"\n    exit 1\n}\nfinally {\n    # Cleanup operations\n    try {\n        $null = Disconnect-MgGraph -ErrorAction SilentlyContinue\n        Write-Information \"Disconnected from Microsoft Graph\" -InformationAction Continue\n    }\n    catch {\n        # Silently ignore disconnect errors as they are not critical to script execution\n        Write-Debug \"Graph disconnect error (non-critical): $($_.Exception.Message)\"\n    }\n}\n\n# ============================================================================\n# SCRIPT SUMMARY\n# ============================================================================\n\nWrite-Information \"\n========================================\nScript Execution Summary\n========================================\nScript: Unassigned Policies Report\nTotal Unassigned Policies: $($UnassignedPolicies.Count)\nExport Path: $($ExportPath ?? 'None')\nStatus: Completed\n========================================\n\" -InformationAction Continue .Exception.Message)\"\n        throw\n    }\n} else {\n    # Local execution - Use interactive authentication\n    # Check if required modules are installed\n    $RequiredModules = @(\n        \"Microsoft.Graph.Authentication\"\n    )\n\n    foreach ($Module in $RequiredModules) {\n        if (-not (Get-Module -ListAvailable -Name $Module)) {\n            Write-Error \"$Module module is required. Install it using: Install-Module $Module -Scope CurrentUser\"\n            exit 1\n        }\n    }\n\n    # Import required modules\n    foreach ($Module in $RequiredModules) {\n        Import-Module $Module\n    }\n\n    # Connect to Microsoft Graph with required scopes\n    try {\n        Write-Information \"Connecting to Microsoft Graph...\" -InformationAction Continue\n        $Scopes = @(\n            \"DeviceManagementConfiguration.Read.All,DeviceManagementApps.Read.All,DeviceManagementManagedDevices.Read.All\"\n        )\n        Connect-MgGraph -Scopes $Scopes -NoWelcome\n        Write-Information \"✓ Successfully connected to Microsoft Graph\" -InformationAction Continue\n    }\n    catch {\n        Write-Error \"Failed to connect to Microsoft Graph: $(<#\n.TITLE\n    Unassigned Policies Report\n\n.SYNOPSIS\n    Identifies all Intune policies that have no group or user assignments\n\n.DESCRIPTION\n    This script connects to Microsoft Graph and analyzes all Intune policies to identify\n    which ones have no assignments. It checks device configuration policies, device compliance\n    policies, app protection policies, and Settings Catalog policies. The script provides a \n    comprehensive report showing policies that may be obsolete or forgotten, helping \n    administrators maintain a clean policy environment.\n\n.TAGS\n    Operational,Reporting\n\n.MINROLE\n    Intune Administrator\n\n.PERMISSIONS\n    DeviceManagementConfiguration.Read.All,DeviceManagementApps.Read.All,DeviceManagementManagedDevices.Read.All\n\n.AUTHOR\n    Ugur Koc\n\n.VERSION\n    1.0\n\n.CHANGELOG\n    1.0 - Initial release\n\n.EXAMPLE\n    .\\get-unassigned-policies.ps1\n    Displays all unassigned policies in the console\n\n.EXAMPLE\n    .\\get-unassigned-policies.ps1 -ExportPath \"C:\\Reports\\UnassignedPolicies.csv\"\n    Exports unassigned policies to a CSV file\n\n.NOTES\n    - Requires only Microsoft.Graph.Authentication module\n    - Uses Connect-MgGraph and Invoke-MgGraphRequest for all Graph operations\n    - Checks policy types: Device Configuration, Device Compliance, App Protection, Settings Catalog\n    - Settings Catalog policies require beta Graph endpoint access\n    - App Protection policies are considered assigned if they exist (different targeting model)\n    - Policies with no assignments may indicate unused or forgotten configurations\n    - Consider reviewing these policies for potential cleanup or assignment\n#>\n\n[CmdletBinding()]\nparam(\n    [Parameter(Mandatory = $false, HelpMessage = \"Path to export the results to CSV file\")]\n    [string]$ExportPath,\n    \n    [Parameter(Mandatory = $false, HelpMessage = \"Include detailed assignment information in output\")]\n    [switch]$IncludeDetails\n)\n\n# ============================================================================\n# MODULES AND AUTHENTICATION\n# ============================================================================\n\n# Check if required modules are installed\n$RequiredModules = @(\n    \"Microsoft.Graph.Authentication\"\n)\n\nforeach ($Module in $RequiredModules) {\n    if (-not (Get-Module -ListAvailable -Name $Module)) {\n        Write-Error \"$Module module is required. Install it using: Install-Module $Module -Scope CurrentUser\"\n        exit 1\n    }\n}\n\n# Import required modules\nforeach ($Module in $RequiredModules) {\n    Import-Module $Module\n}\n\n# Connect to Microsoft Graph\ntry {\n    Write-Information \"Connecting to Microsoft Graph...\" -InformationAction Continue\n    $Scopes = @(\n        \"DeviceManagementConfiguration.Read.All\",\n        \"DeviceManagementApps.Read.All\",\n        \"DeviceManagementManagedDevices.Read.All\"\n    )\n    Connect-MgGraph -Scopes $Scopes -NoWelcome\n    Write-Information \"✓ Successfully connected to Microsoft Graph\" -InformationAction Continue\n}\ncatch {\n    Write-Error \"Failed to connect to Microsoft Graph: $($_.Exception.Message)\"\n    exit 1\n}\n\n# ============================================================================\n# HELPER FUNCTIONS\n# ============================================================================\n\n# Function to get all pages of results from Graph API\nfunction Get-MgGraphAllPage {\n    param(\n        [Parameter(Mandatory = $true)]\n        [string]$Uri,\n        [int]$DelayMs = 100\n    )\n    \n    $AllResults = @()\n    $NextLink = $Uri\n    $RequestCount = 0\n    \n    do {\n        try {\n            # Add delay to respect rate limits\n            if ($RequestCount -gt 0) {\n                Start-Sleep -Milliseconds $DelayMs\n            }\n            \n            $Response = Invoke-MgGraphRequest -Uri $NextLink -Method GET\n            $RequestCount++\n            \n            if ($Response.value) {\n                $AllResults += $Response.value\n            }\n            else {\n                $AllResults += $Response\n            }\n            \n            $NextLink = $Response.'@odata.nextLink'\n        }\n        catch {\n            if ($_.Exception.Message -like \"*429*\" -or $_.Exception.Message -like \"*throttled*\") {\n                Write-Information \"`nRate limit hit, waiting 60 seconds...\" -InformationAction Continue\n                Start-Sleep -Seconds 60\n                continue\n            }\n            Write-Warning \"Error fetching data from $NextLink : $($_.Exception.Message)\"\n            break\n        }\n    } while ($NextLink)\n    \n    return $AllResults\n}\n\n# Function to check if a policy has assignments\nfunction Test-PolicyAssignment {\n    param(\n        [Parameter(Mandatory = $true)]\n        [string]$PolicyId,\n        [Parameter(Mandatory = $true)]\n        [string]$PolicyType\n    )\n    \n    # Check if PolicyId is valid\n    if ([string]::IsNullOrWhiteSpace($PolicyId)) {\n        Write-Warning \"PolicyId is empty or null for $PolicyType policy\"\n        return $false\n    }\n    \n    try {\n        # App Protection policies use a different targeting mechanism\n        if ($PolicyType -eq \"AppProtection\") {\n            # App Protection policies don't use traditional assignments\n            # They are applied to applications and considered active if they exist\n            try {\n                # Verify the policy exists and is accessible\n                $PolicyUri = \"https://graph.microsoft.com/v1.0/deviceAppManagement/managedAppPolicies/$PolicyId\"\n                $null = Invoke-MgGraphRequest -Uri $PolicyUri -Method GET\n                \n                # App Protection policies are considered \"assigned\" if they exist and are published\n                # Most App Protection policies that exist are active/assigned to applications\n                return $true\n            }\n            catch {\n                # If we can't access the policy, it might not be properly configured\n                return $false\n            }\n        }\n        else {\n            $AssignmentUri = switch ($PolicyType) {\n                \"DeviceConfiguration\" { \"https://graph.microsoft.com/v1.0/deviceManagement/deviceConfigurations/$PolicyId/assignments\" }\n                \"DeviceCompliance\" { \"https://graph.microsoft.com/v1.0/deviceManagement/deviceCompliancePolicies/$PolicyId/assignments\" }\n                \"SettingsCatalog\" { \"https://graph.microsoft.com/beta/deviceManagement/configurationPolicies/$PolicyId/assignments\" }\n                default { return $false }\n            }\n            \n            $Assignments = Get-MgGraphAllPage -Uri $AssignmentUri\n            return $Assignments.Count -gt 0\n        }\n    }\n    catch {\n        Write-Warning \"Could not check assignments for policy $PolicyId : $($_.Exception.Message)\"\n        return $false\n    }\n}\n\n# Function to get policy details\nfunction Get-PolicyDetail {\n    param(\n        [Parameter(Mandatory = $true)]\n        [object]$Policy,\n        [Parameter(Mandatory = $true)]\n        [string]$PolicyType\n    )\n    \n    # Settings Catalog policies use 'name' instead of 'displayName'\n    $PolicyDisplayName = if ($PolicyType -eq \"SettingsCatalog\") {\n        $Policy.name\n    }\n    else {\n        $Policy.displayName\n    }\n    \n    $Details = [PSCustomObject]@{\n        PolicyType           = $PolicyType\n        PolicyId             = $Policy.id\n        DisplayName          = $PolicyDisplayName\n        Description          = $Policy.description\n        CreatedDateTime      = $Policy.createdDateTime\n        LastModifiedDateTime = $Policy.lastModifiedDateTime\n        Version              = $Policy.version\n        HasAssignments       = $false\n    }\n    \n    # Check for assignments\n    $Details.HasAssignments = Test-PolicyAssignment -PolicyId $Policy.id -PolicyType $PolicyType\n    \n    return $Details\n}\n\n# ============================================================================\n# MAIN SCRIPT LOGIC\n# ============================================================================\n\ntry {\n    Write-Information \"Starting unassigned policies analysis...\" -InformationAction Continue\n    \n    $UnassignedPolicies = @()\n    $PolicyTypes = @(\n        @{ Name = \"DeviceConfiguration\"; Uri = \"https://graph.microsoft.com/v1.0/deviceManagement/deviceConfigurations\" },\n        @{ Name = \"DeviceCompliance\"; Uri = \"https://graph.microsoft.com/v1.0/deviceManagement/deviceCompliancePolicies\" },\n        @{ Name = \"AppProtection\"; Uri = \"https://graph.microsoft.com/v1.0/deviceAppManagement/managedAppPolicies\" },\n        @{ Name = \"SettingsCatalog\"; Uri = \"https://graph.microsoft.com/beta/deviceManagement/configurationPolicies\" }\n    )\n    \n    foreach ($PolicyType in $PolicyTypes) {\n        Write-Information \"Analyzing $($PolicyType.Name) policies...\" -InformationAction Continue\n        \n        try {\n            $Policies = Get-MgGraphAllPage -Uri $PolicyType.Uri\n            # Handle null or empty results\n            if (-not $Policies) {\n                $Policies = @()\n            }\n            Write-Information \"Found $($Policies.Count) $($PolicyType.Name) policies\" -InformationAction Continue\n            \n            foreach ($Policy in $Policies) {\n                # Skip policies with empty or null IDs\n                if ([string]::IsNullOrWhiteSpace($Policy.id)) {\n                    $PolicyName = if ($PolicyType.Name -eq \"SettingsCatalog\") { $Policy.name } else { $Policy.displayName }\n                    Write-Warning \"Skipping policy with empty ID: $($PolicyName ?? 'Unknown')\"\n                    continue\n                }\n                \n                $PolicyDetails = Get-PolicyDetail -Policy $Policy -PolicyType $PolicyType.Name\n                \n                # Get the correct display name for Settings Catalog vs other policies\n                $DisplayName = if ($PolicyType.Name -eq \"SettingsCatalog\") {\n                    $Policy.name\n                }\n                else {\n                    $Policy.displayName\n                }\n                \n                if (-not $PolicyDetails.HasAssignments) {\n                    $UnassignedPolicies += $PolicyDetails\n                    Write-Information \"✗ Unassigned: $DisplayName ($($PolicyType.Name))\" -InformationAction Continue\n                }\n                else {\n                    Write-Information \"✓ Assigned: $DisplayName ($($PolicyType.Name))\" -InformationAction Continue\n                }\n            }\n        }\n        catch {\n            Write-Warning \"Error analyzing $($PolicyType.Name) policies: $($_.Exception.Message)\"\n        }\n    }\n    \n    # Display results\n    Write-Information \"`n========================================\" -InformationAction Continue\n    Write-Information \"UNASSIGNED POLICIES SUMMARY\" -InformationAction Continue\n    Write-Information \"========================================\" -InformationAction Continue\n    \n    if ($UnassignedPolicies.Count -eq 0) {\n        Write-Information \"✓ No unassigned policies found - all policies have assignments!\" -InformationAction Continue\n    }\n    else {\n        Write-Information \"Found $($UnassignedPolicies.Count) policies without assignments:\" -InformationAction Continue\n        \n        $GroupedPolicies = $UnassignedPolicies | Group-Object PolicyType\n        foreach ($Group in $GroupedPolicies) {\n            Write-Information \"`n$($Group.Name) Policies ($($Group.Count)):\" -InformationAction Continue\n            foreach ($Policy in $Group.Group) {\n                Write-Information \"  - $($Policy.DisplayName)\" -InformationAction Continue\n                if ($IncludeDetails) {\n                    Write-Information \"    ID: $($Policy.PolicyId)\" -InformationAction Continue\n                    Write-Information \"    Created: $($Policy.CreatedDateTime)\" -InformationAction Continue\n                    Write-Information \"    Modified: $($Policy.LastModifiedDateTime)\" -InformationAction Continue\n                }\n            }\n        }\n        \n        # Export to CSV if path provided\n        if ($ExportPath) {\n            try {\n                $UnassignedPolicies | Export-Csv -Path $ExportPath -NoTypeInformation\n                Write-Information \"`n✓ Results exported to: $ExportPath\" -InformationAction Continue\n            }\n            catch {\n                Write-Error \"Failed to export results: $($_.Exception.Message)\"\n            }\n        }\n    }\n    \n    Write-Information \"`n✓ Analysis completed successfully\" -InformationAction Continue\n}\ncatch {\n    Write-Error \"Script failed: $($_.Exception.Message)\"\n    exit 1\n}\nfinally {\n    # Cleanup operations\n    try {\n        $null = Disconnect-MgGraph -ErrorAction SilentlyContinue\n        Write-Information \"Disconnected from Microsoft Graph\" -InformationAction Continue\n    }\n    catch {\n        # Silently ignore disconnect errors as they are not critical to script execution\n        Write-Debug \"Graph disconnect error (non-critical): $($_.Exception.Message)\"\n    }\n}\n\n# ============================================================================\n# SCRIPT SUMMARY\n# ============================================================================\n\nWrite-Information \"\n========================================\nScript Execution Summary\n========================================\nScript: Unassigned Policies Report\nTotal Unassigned Policies: $($UnassignedPolicies.Count)\nExport Path: $($ExportPath ?? 'None')\nStatus: Completed\n========================================\n\" -InformationAction Continue .Exception.Message)\"\n        exit 1\n    }\n}# ============================================================================\n# HELPER FUNCTIONS\n# ============================================================================\n\n# Function to get all pages of results from Graph API\nfunction Get-MgGraphAllPage {\n    param(\n        [Parameter(Mandatory = $true)]\n        [string]$Uri,\n        [int]$DelayMs = 100\n    )\n    \n    $AllResults = @()\n    $NextLink = $Uri\n    $RequestCount = 0\n    \n    do {\n        try {\n            # Add delay to respect rate limits\n            if ($RequestCount -gt 0) {\n                Start-Sleep -Milliseconds $DelayMs\n            }\n            \n            $Response = Invoke-MgGraphRequest -Uri $NextLink -Method GET\n            $RequestCount++\n            \n            if ($Response.value) {\n                $AllResults += $Response.value\n            }\n            else {\n                $AllResults += $Response\n            }\n            \n            $NextLink = $Response.'@odata.nextLink'\n        }\n        catch {\n            if ($_.Exception.Message -like \"*429*\" -or $_.Exception.Message -like \"*throttled*\") {\n                Write-Information \"`nRate limit hit, waiting 60 seconds...\" -InformationAction Continue\n                Start-Sleep -Seconds 60\n                continue\n            }\n            Write-Warning \"Error fetching data from $NextLink : $($_.Exception.Message)\"\n            break\n        }\n    } while ($NextLink)\n    \n    return $AllResults\n}\n\n# Function to check if a policy has assignments\nfunction Test-PolicyAssignment {\n    param(\n        [Parameter(Mandatory = $true)]\n        [string]$PolicyId,\n        [Parameter(Mandatory = $true)]\n        [string]$PolicyType\n    )\n    \n    # Check if PolicyId is valid\n    if ([string]::IsNullOrWhiteSpace($PolicyId)) {\n        Write-Warning \"PolicyId is empty or null for $PolicyType policy\"\n        return $false\n    }\n    \n    try {\n        # App Protection policies use a different targeting mechanism\n        if ($PolicyType -eq \"AppProtection\") {\n            # App Protection policies don't use traditional assignments\n            # They are applied to applications and considered active if they exist\n            try {\n                # Verify the policy exists and is accessible\n                $PolicyUri = \"https://graph.microsoft.com/v1.0/deviceAppManagement/managedAppPolicies/$PolicyId\"\n                $null = Invoke-MgGraphRequest -Uri $PolicyUri -Method GET\n                \n                # App Protection policies are considered \"assigned\" if they exist and are published\n                # Most App Protection policies that exist are active/assigned to applications\n                return $true\n            }\n            catch {\n                # If we can't access the policy, it might not be properly configured\n                return $false\n            }\n        }\n        else {\n            $AssignmentUri = switch ($PolicyType) {\n                \"DeviceConfiguration\" { \"https://graph.microsoft.com/v1.0/deviceManagement/deviceConfigurations/$PolicyId/assignments\" }\n                \"DeviceCompliance\" { \"https://graph.microsoft.com/v1.0/deviceManagement/deviceCompliancePolicies/$PolicyId/assignments\" }\n                \"SettingsCatalog\" { \"https://graph.microsoft.com/beta/deviceManagement/configurationPolicies/$PolicyId/assignments\" }\n                default { return $false }\n            }\n            \n            $Assignments = Get-MgGraphAllPage -Uri $AssignmentUri\n            return $Assignments.Count -gt 0\n        }\n    }\n    catch {\n        Write-Warning \"Could not check assignments for policy $PolicyId : $($_.Exception.Message)\"\n        return $false\n    }\n}\n\n# Function to get policy details\nfunction Get-PolicyDetail {\n    param(\n        [Parameter(Mandatory = $true)]\n        [object]$Policy,\n        [Parameter(Mandatory = $true)]\n        [string]$PolicyType\n    )\n    \n    # Settings Catalog policies use 'name' instead of 'displayName'\n    $PolicyDisplayName = if ($PolicyType -eq \"SettingsCatalog\") {\n        $Policy.name\n    }\n    else {\n        $Policy.displayName\n    }\n    \n    $Details = [PSCustomObject]@{\n        PolicyType           = $PolicyType\n        PolicyId             = $Policy.id\n        DisplayName          = $PolicyDisplayName\n        Description          = $Policy.description\n        CreatedDateTime      = $Policy.createdDateTime\n        LastModifiedDateTime = $Policy.lastModifiedDateTime\n        Version              = $Policy.version\n        HasAssignments       = $false\n    }\n    \n    # Check for assignments\n    $Details.HasAssignments = Test-PolicyAssignment -PolicyId $Policy.id -PolicyType $PolicyType\n    \n    return $Details\n}\n\n# ============================================================================\n# MAIN SCRIPT LOGIC\n# ============================================================================\n\ntry {\n    Write-Information \"Starting unassigned policies analysis...\" -InformationAction Continue\n    \n    $UnassignedPolicies = @()\n    $PolicyTypes = @(\n        @{ Name = \"DeviceConfiguration\"; Uri = \"https://graph.microsoft.com/v1.0/deviceManagement/deviceConfigurations\" },\n        @{ Name = \"DeviceCompliance\"; Uri = \"https://graph.microsoft.com/v1.0/deviceManagement/deviceCompliancePolicies\" },\n        @{ Name = \"AppProtection\"; Uri = \"https://graph.microsoft.com/v1.0/deviceAppManagement/managedAppPolicies\" },\n        @{ Name = \"SettingsCatalog\"; Uri = \"https://graph.microsoft.com/beta/deviceManagement/configurationPolicies\" }\n    )\n    \n    foreach ($PolicyType in $PolicyTypes) {\n        Write-Information \"Analyzing $($PolicyType.Name) policies...\" -InformationAction Continue\n        \n        try {\n            $Policies = Get-MgGraphAllPage -Uri $PolicyType.Uri\n            # Handle null or empty results\n            if (-not $Policies) {\n                $Policies = @()\n            }\n            Write-Information \"Found $($Policies.Count) $($PolicyType.Name) policies\" -InformationAction Continue\n            \n            foreach ($Policy in $Policies) {\n                # Skip policies with empty or null IDs\n                if ([string]::IsNullOrWhiteSpace($Policy.id)) {\n                    $PolicyName = if ($PolicyType.Name -eq \"SettingsCatalog\") { $Policy.name } else { $Policy.displayName }\n                    Write-Warning \"Skipping policy with empty ID: $($PolicyName ?? 'Unknown')\"\n                    continue\n                }\n                \n                $PolicyDetails = Get-PolicyDetail -Policy $Policy -PolicyType $PolicyType.Name\n                \n                # Get the correct display name for Settings Catalog vs other policies\n                $DisplayName = if ($PolicyType.Name -eq \"SettingsCatalog\") {\n                    $Policy.name\n                }\n                else {\n                    $Policy.displayName\n                }\n                \n                if (-not $PolicyDetails.HasAssignments) {\n                    $UnassignedPolicies += $PolicyDetails\n                    Write-Information \"✗ Unassigned: $DisplayName ($($PolicyType.Name))\" -InformationAction Continue\n                }\n                else {\n                    Write-Information \"✓ Assigned: $DisplayName ($($PolicyType.Name))\" -InformationAction Continue\n                }\n            }\n        }\n        catch {\n            Write-Warning \"Error analyzing $($PolicyType.Name) policies: $($_.Exception.Message)\"\n        }\n    }\n    \n    # Display results\n    Write-Information \"`n========================================\" -InformationAction Continue\n    Write-Information \"UNASSIGNED POLICIES SUMMARY\" -InformationAction Continue\n    Write-Information \"========================================\" -InformationAction Continue\n    \n    if ($UnassignedPolicies.Count -eq 0) {\n        Write-Information \"✓ No unassigned policies found - all policies have assignments!\" -InformationAction Continue\n    }\n    else {\n        Write-Information \"Found $($UnassignedPolicies.Count) policies without assignments:\" -InformationAction Continue\n        \n        $GroupedPolicies = $UnassignedPolicies | Group-Object PolicyType\n        foreach ($Group in $GroupedPolicies) {\n            Write-Information \"`n$($Group.Name) Policies ($($Group.Count)):\" -InformationAction Continue\n            foreach ($Policy in $Group.Group) {\n                Write-Information \"  - $($Policy.DisplayName)\" -InformationAction Continue\n                if ($IncludeDetails) {\n                    Write-Information \"    ID: $($Policy.PolicyId)\" -InformationAction Continue\n                    Write-Information \"    Created: $($Policy.CreatedDateTime)\" -InformationAction Continue\n                    Write-Information \"    Modified: $($Policy.LastModifiedDateTime)\" -InformationAction Continue\n                }\n            }\n        }\n        \n        # Export to CSV if path provided\n        if ($ExportPath) {\n            try {\n                $UnassignedPolicies | Export-Csv -Path $ExportPath -NoTypeInformation\n                Write-Information \"`n✓ Results exported to: $ExportPath\" -InformationAction Continue\n            }\n            catch {\n                Write-Error \"Failed to export results: $($_.Exception.Message)\"\n            }\n        }\n    }\n    \n    Write-Information \"`n✓ Analysis completed successfully\" -InformationAction Continue\n}\ncatch {\n    Write-Error \"Script failed: $($_.Exception.Message)\"\n    exit 1\n}\nfinally {\n    # Cleanup operations\n    try {\n        $null = Disconnect-MgGraph -ErrorAction SilentlyContinue\n        Write-Information \"Disconnected from Microsoft Graph\" -InformationAction Continue\n    }\n    catch {\n        # Silently ignore disconnect errors as they are not critical to script execution\n        Write-Debug \"Graph disconnect error (non-critical): $($_.Exception.Message)\"\n    }\n}\n\n# ============================================================================\n# SCRIPT SUMMARY\n# ============================================================================\n\nWrite-Information \"\n========================================\nScript Execution Summary\n========================================\nScript: Unassigned Policies Report\nTotal Unassigned Policies: $($UnassignedPolicies.Count)\nExport Path: $($ExportPath ?? 'None')\nStatus: Completed\n========================================\n\" -InformationAction Continue ",
    "logVerbose": false
  },
  "resources": [
    {
      "name": "[concat(parameters('automationAccountName'), '/', parameters('runbookName'))]",
      "apiVersion": "2020-01-13-preview",
      "type": "Microsoft.Automation/automationAccounts/runbooks",
      "properties": {
        "runbookType": "[variables('runbookType')]",
        "draft": {
          "inEdit": false
        },
        "logProgress": "[variables('logProgress')]",
        "description": "[parameters('runbookDescription')]",
        "logVerbose": "[variables('logVerbose')]"
      }
    },
    {
      "name": "[concat(parameters('automationAccountName'), '/', parameters('runbookName'), '/draft')]",
      "apiVersion": "2020-01-13-preview",
      "type": "Microsoft.Automation/automationAccounts/runbooks/draft",
      "properties": {
        "description": "[parameters('runbookDescription')]",
        "content": "[variables('scriptContent')]"
      },
      "dependsOn": [
        "[resourceId('Microsoft.Automation/automationAccounts/runbooks', parameters('automationAccountName'), parameters('runbookName'))]"
      ]
    }
  ],
  "contentVersion": "1.0.0.0",
  "outputs": {
    "runbookName": {
      "type": "string",
      "value": "[parameters('runbookName')]"
    },
    "deploymentInstructions": {
      "type": "string",
      "value": "Runbook created successfully. You may need to publish the runbook draft and configure managed identity permissions for Microsoft Graph access."
    },
    "automationAccountName": {
      "type": "string",
      "value": "[parameters('automationAccountName')]"
    }
  },
  "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#"
}
